<html>

<head>
<title>Cai Cai Foguete</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vColor;

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
        gl_FragColor = vColor*texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;
    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
        vTextureCoord = aTextureCoord;
    }
</script>


<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
    }

    function handleLoadedTexture(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    var minhaTextura;

    function initTexture() {
        minhaTextura = gl.createTexture();
        minhaTextura.image = new Image();
        minhaTextura.image.onload = function () {
            handleLoadedTexture(minhaTextura)
        }

        minhaTextura.image.src = "tex.jpg";
    }

    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }


    var FogVerPos;
    var FogVerCol;
    var FogVerTex;
    var FogVerInd;

    function initBuffers() {

        FogVerPos = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, FogVerPos);
        var vertices = [
            0.0, 1.0, 0.0, //Topo da pirâmide
            //Hexágono superior
            1.0, 0.5, 0.0, //H1
            0.6, 0.5, 1.0, //H2
            -0.6, 0.5, 1.0, //H3
            -1.0, 0.5, 0.0, //H4
            -0.6, 0.5, -1.0, //H5
            0.6, 0.5, -1.0, //H6
            //Hexágono inferior
            1.0, -1.0, 0.0, //H7
            0.6, -1.0, 1.0, //H8
            -0.6, -1.0, 1.0, //H9
            -1.0, -1.0, 0.0, //H10
            -0.6, -1.0, -1.0, //H11
            0.6, -1.0, -1.0 //H12
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        FogVerPos.itemSize = 3;
        FogVerPos.numItems = 13;

        FogVerCol = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, FogVerCol);
        var cores = [
            //Triângulo superior
            0.0, 1.0, 0.0, 1.0,
            //Hexágono superior
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            //Hexágono inferior 
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cores), gl.STATIC_DRAW);
        FogVerCol.itemSize = 4;
        FogVerCol.numItems = 13;

        FogVerTex = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, FogVerTex);
        var texture = [
            //Topo da pirâmide
            0.5, 0.5,
            //Vértices da parte superior (Mapeia em um hexágono num plano)
            0.6, 0.0,
            0.3, 0.0,
            0.0, 0.5,
            0.3, 1.0,
            0.6, 1.0,
            1.0, 0.5,
            //Vértices da parte inferior
            0.6, 0.0,
            0.3, 0.0,
            0.0, 0.5,
            0.3, 1.0,
            0.6, 1.0,
            1.0, 0.5,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture), gl.STATIC_DRAW);
        FogVerTex.itemSize = 2;
        FogVerTex.numItems = 13;

        FogVerInd = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, FogVerInd);
        var indices = [
            //Triângulo de cima
            0, 2, 1,
            0, 3, 2,
            0, 4, 3,
            0, 5, 4,
            0, 6, 5,
            0, 1, 6, 
            //Hexágono de baixo
            1, 2, 7,  2, 8, 7,
            2, 3, 8,  3, 9, 8,
            3, 4, 9,  4, 10, 9,
            4, 5, 10,  5, 11, 10,
            5, 6, 11,  6, 12, 11,
            6, 1, 12,  1, 7, 12, 
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        FogVerInd.itemSize = 1;
        FogVerInd.numItems = 54;
    }

    var angMax = 180;
    var FogRot = 0;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [0.0, 0.0, -15.0]);

        if (FogRot <= angMax)
            mat4.rotate(mvMatrix, degToRad(FogRot), [0.0, 0.0, -1.0]);
        else
            FogRot = 0;

        mat4.translate(mvMatrix, [-5.0, 0.0, 0.0]);

        gl.bindBuffer(gl.ARRAY_BUFFER, FogVerPos);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, FogVerPos.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, FogVerTex);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, FogVerTex.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, FogVerCol);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, FogVerCol.itemSize, gl.FLOAT, false, 0, 0);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, minhaTextura);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, FogVerInd);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, FogVerInd.numItems, gl.UNSIGNED_SHORT, 0);


    }


    var lastTime = 0;

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

            FogRot += (60 * elapsed) / 1000.0;
        }

        lastTime = timeNow;
    }


    function tick() {
        requestAnimFrame(tick);
        drawScene();
        animate();
    }


    function webGLStart() {
        var canvas = document.getElementById("lesson04-canvas");
        initGL(canvas);
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        tick();
    }

</script>


</head>


<body onload="webGLStart();">

    <canvas id="lesson04-canvas" style="border: none;" width="500" height="500"></canvas>

    <br/>
</body>

</html>
